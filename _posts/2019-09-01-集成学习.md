---
layout:       post
title:        集成学习
subtitle:     ML
date:         2019-09-01
author:       JAN
header-img:   img/post-bg-mistake.jpeg
catalog:      true
mathjax:	  true
tags:
    - ML
---

# 集成学习分为哪几种？他们有何异同？

## Boosting

Boosting方法训练基分类器时采用串行的方式，各个基分类器之间有依赖。它的基本思想是将基分类器层层叠加，每一层在训练的时候，对前一层基分类器分错的样本，给予更高的权重。测试时，根据各层分类器的结果的加权得到最终结果。Boosting能够提升弱分类器的性能的原因是降低了偏差。

## Bagging

Bagging方法训练基分类器时采用并行的方式，各个基分类器之间无强依赖。Bagging能够提升弱分类器的性能的原因是降低了方差。

典型算法是随机森林，为了让基分类器相互独立，将训练集分为若干子集（当训练样本数量较少时，子集之间可能有重叠），最后通过投票的方式作出最后的集体决策。

# 什么是偏差和方差？

偏差指的是由**所有采样得到的大小为m的训练数据集训练出的所有模型的输出的平均值**和真实模型输出之间的偏差。

方差是指由所有采样得到的大小为m的训练数据集训练出的所有模型输出的方差。

# 常用的基分类器是什么？

最常用的基分类器是决策树，主要有以下三方面的原因。

1. 决策树可以较为方便地将样本的权重整合到训练过程中，而不需要使用过采样的方法来调整样本权重；

2. 决策树的表达能力和泛化能力，可以通过调节树的层数来做折中；

3. 数据样本的扰动对于决策树的影响较大，因此不同子样本集合生成的决策树基分类器随机性较大，这样的“不稳定学习器”更适合作为基分类器。此外，在决策树节点分裂的时候，随机选择一个特征子集，从中找出最优分裂属性，很好地引入了随机性；

除了决策树以外，神经网络模型也适合作为基分类器，主要是由于神经网络模型也比较“不稳定”，而且还可以通过调整神经元数量、连接方式、网络层数、初始权重等方式引入随机性。

# 决策树

决策树由结点和有向边组成。

## 决策树的构造

确定各个特征属性之间的拓扑结构。构造决策树的关键步骤是**分裂属性**。分裂属性的目的是让一个子集中待分类项尽量属于同一个类别。

### ID3.5

ID3.5属于一种贪心算法，选择熵减小程度最大的特征来划分数据。

熵的计算公式：$H=-\sum{\frac{|C_k|}{D}log_2(\frac{|C_k|}{D})}$。

条件熵的计算公式：$H(D|A)=\sum{\frac{D_i}{D}H(D_i)}$

即特征$A$下属性$A_i$有$D_i$个样本...

### C4.5

对于较多属性值的特征，选择它之后的熵减小程度也会越大，因为属性值越多，混乱程度必然越少。ID3.5也是这个原因会优先选择属性值较多的特征进行分裂，因此再除以一个关于特征属性值的熵，依然以上述$A$举例，即除去一个$-\sum{\frac{|A_i|}{A}log_2(\frac{|A_i|}{A})}$。

### CART

CART相比于上述两个，既可以用于分类也可以用于回归。CART使用Gini指数来选择分裂的特征。

$Gini(D)=1-\sum{\left(\frac{D_i}{D}\right)^2}$

# GBDT

相比于Bagging中各个弱分类器可以独立地进行训练，Boosting中的弱分类器需要依次生成。在每一次迭代中，基于已生成的弱分类器集合（即当前模型）的预测结果，新的弱分类器会重点关注那些还没有被正确预测的样本。

## 梯度提升和梯度下降的区别和联系

两者都是在每一轮迭代中，利用损失函数相对于模型的负梯度方向的信息来对当前模型进行更新。只不过在梯度下降中，模型是以参数化形式表示，从而模型的更新等价于参数的更新。而在梯度提升中，模型并不需要进行参数化表示，而是直接定义在函数空间中，从而大大扩展了可以使用的模型种类。

## GBDT的优缺点

### 优点

1. 预测阶段的计算速度快，树与树之间可以并行化计算；
2. 在分布稠密的数据集上，泛化能力和表达能力都很好；
3. 采用决策树作为弱分类器是的GBDT模型具有较好的解释性和鲁棒性；

### 缺点

1. GBDT在高维稀疏的数据集上，表现不如SVM或者神经网络；
2. 训练过程需要串行训练，只能在决策树内部采用一些局部并行的手段提高训练速度；

# GBDT和XGBoost的区别和联系

1. GBDT是机器学习算法，XGBoost是该算法的工程实现；
2. 在使用CART作为弱分类器时，XGBoost显式地加入了正则项来控制模型的复杂度，有利于防止过拟合；
3. GBDT在模型训练时只利用了代价函数的一阶导数信息，XGBoost对代价函数进行二阶泰勒展开，可以利用一阶和二阶导数；
4. GBDT采用CART作为基分类器，XGBoost支持多种类型的基分类器，例如线性分类器；
5. GBDT每次迭代都使用全部的基分类器，XGBoost采用了与随机森林相似的策略，支持对数据进行采样；
6. GBDT没有对缺失值进行处理，XGBoost能够自动学习出缺失值的处理策略；
